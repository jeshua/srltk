package srltk.tools.linearalgebra
import org.netlib.lapack._
import org.netlib.util.intW
import scalala.library.LinearAlgebra._
import scalala.operators._
import scalala.scalar.Scalar
import scalala.generic.collection.CanViewAsVector
import scalala.tensor.domain.TableDomain
import scalala.tensor.dense.{ DenseVector, DenseMatrix }
import scalala.tensor.{DiagonalMatrix, MatrixSingularException, Matrix, Vector }
import scalala.library.MatrixEmptyException
import scalala.library.NotConvergedException


package object LinearAlgebra {

  private def requireNonEmptyMatrix[V](mat: Matrix[V]) = {
    if (mat.numCols == 0 || mat.numRows == 0)
      throw new MatrixEmptyException
  }
  
  
  /**
   * Find set of linearly independent columns
   * 
   * input: A m x n matrix,
   *        pvt  : pivot array returned by qrp
   *        rank : estimated (number of indep columns)
   * output: C (m x rank) where each column is linearly independent
   */
  def linIndepCols(A : DenseMatrix[Double], pvt : Array[Int], rank : Int) : DenseMatrix[Double] = {
	  val m = A.numRows
	  val ret = DenseMatrix.zeros[Double](m,rank)
	  for(i <- 0 until rank)
		  ret(0 until m, i) := A(0 until m,pvt(i))
	  ret	  
  }  
  
  /**
   * Estimate rank using SVD
   * 
   * input: A matrix of interest
   *        D from SVD (singular values)
   *        thresh threshold on singular values values
   * output: estimated rank
   */
  def estRankSVD(D : DenseVector[Double], thresh : Double = 1e-10) : Int = {
	  val m = D.length
	   def r(rank : Int) : Int = {
    	  if(math.abs(D(rank)) > thresh && rank < m-1) r(rank+1)
    	  else rank
	  }
	  math.max(r(0),1)
  }
  
  /**
   * Estimate rank using QF Factorization
   * 
   * input: A matrix of interest
   *        R from qr factorization
   *        thresh threshold on R values
   * output: estimated rank
   */
  def estRankQR(R : DenseMatrix[Double], thresh : Double = 1e-10) : Int = {
	  val m = math.min(R.numRows,R.numCols)
	  def r(rank : Int) : Int = {
    	  if(math.abs(R(rank, rank)) > thresh && rank < m-1) r(rank+1)
    	  else rank
	  }
	  math.max(r(0),1)
  }
  
  /**
   * QR Factorization with pivoting
   * 
   * input: A m x n matrix
   * output: (Q,R,P,pvt) where AP = QR  
   *   Q: m x m
   *   R: m x n 
   *   P: n x n : permutation matrix (P(pvt(i),i) = 1)
   *   pvt : pivot indices
   */
  def qrp(A: DenseMatrix[Double]): (DenseMatrix[Double], DenseMatrix[Double], DenseMatrix[Int], Array[Int]) = {
    val m = A.numRows
    val n = A.numCols
    val lapack = LAPACK.getInstance();

    //Get optimal workspace size 
    // we do this by sending -1 as lwork to the lapack function
    val work = new Array[Double](1)
    var info = new intW(0)
    lapack.dgeqrf(m, n, null, m, null, work, -1, info);
    val lwork1 = if(info.`val` != 0) n else work(0).toInt
    lapack.dorgqr(m, m, math.min(m,n), null, m, null, work, -1, info);
    val lwork2 = if(info.`val` != 0) n else work(0).toInt;
    //allocate workspace mem. as max of lwork1 and lwork3
    val workspace = new Array[Double](math.max(lwork1, lwork2));
    
    //Perform the QR factorization with dgep3
    val maxd = math.max(m,n)
    val AFact = DenseMatrix.zeros[Double](m,maxd)
    val pvt = new Array[Int](n)
    val tau = new Array[Double](math.min(m,n))
    for(r <- 0 until m; c <- 0 until n) AFact(r,c) = A(r,c)
    lapack.dgeqp3(m, n, AFact.data, m, pvt, tau, workspace, workspace.length, info);
    
    //Error check
    if (info.`val` > 0)
      throw new NotConvergedException(NotConvergedException.Iterations)
    else if (info.`val` < 0)
      throw new IllegalArgumentException()
 
    //Get R
    val R = DenseMatrix.zeros[Double](m,n)
    for(c <- 0 until maxd if(c < n);
        r <- 0 until m if(r <= c)) 
    	R(r,c) = AFact(r,c)    
    
    //Get Q from the matrix returned by dgep3
    val Q = DenseMatrix.zeros[Double](m,m)    
    lapack.dorgqr(m, m, math.min(m,n), AFact.data, m, tau, workspace, workspace.length, info);
    for(r <- 0 until m;
        c <- 0 until maxd if(c < m)) 
    	Q(r,c) = AFact(r,c)
    	
    //Error check
    if (info.`val` > 0)
      throw new NotConvergedException(NotConvergedException.Iterations)
    else if (info.`val` < 0)
      throw new IllegalArgumentException()
    	
   	//Get P
   	for(i <- 0 until pvt.length) pvt(i)-=1
    val P = DenseMatrix.zeros[Int](n,n)
    for(i <- 0 until n)
    	P(pvt(i), i) = 1                
                
    (Q,R,P,pvt)
  }
}
